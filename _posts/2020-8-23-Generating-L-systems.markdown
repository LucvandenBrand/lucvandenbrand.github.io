---
layout: post
title:  "Generating L-systems"
summary: "How to generate an L-system using basic sequential methods."
date:   2020-8-23
categories: tutorial programming l-system
---

An L-system is a mathematical notation that allows for generating beautiful self-repeating structures from a set of symbols and rules that apply to them. Suppose we want to mathematically model [a fractal](https://en.wikipedia.org/wiki/Fractal), we define an L-system as a tuple

$$ G=(V, \omega, P) $$

in which $$V$$ is our alphabet: all possible symbols that can exist within our system. The $$\omega$$ is the initial set of symbols from which we can start applying our rewrite rules: our previously mentioned axiom. Finally we have $$P$$, which consists of all rules that determine how a string of symbols needs to be rewritten to form the next iteration of symbols.

The rewrite rules can be defined as 

$$
    p_i = v_i \rightarrow v_1 \Vert \dots \Vert v_N,
$$

where every rule $$p_i$$ is contained in $$P$$, and every symbol $$v_i$$ is contained in $$V$$. The symbols before the arrow are called the _antecedent_, whereas symbols after the arrow are called the _consequent_. We use the $$\Vert$$ sign to denote a binary operator which concatenates its left and right symbols. For instance, $$A \Vert B = AB$$. The total number of symbols which are concatenated in the consequent is equal to $$N$$. 

In short, a rule declares that all symbols that match the antecedent must be rewritten to represent the consequent. Not all $$v_i$$ need to exist as an antecedent, such symbols are _constants_. Symbols that are rewritten are called _variables_.

Let us now generate a Sierpinski arrowhead. This fractal can be generated by interpreting the iterations of the L-system

$$ G_{s} = (V_s, \omega_s, P_s), $$

where

$$ V_s = \{ A, B, -, + \}, $$

$$ \omega_s = A, $$

$$ P_s = \{ A \rightarrow B-A-B, B \rightarrow A+B+A \}, $$

which define the instructions for a turtle graphics renderer. Turtle graphics are generated by moving a virtual paintbrush (the turtle) across a virtual canvas by interpreting a series of commands. In this instance both $$A$$ and $$B$$ require the turtle to move forward, whilst $$+$$ and $$-$$ require the turtle to rotate $$60^{\circ}$$ left and right, respectively. The result can be seen below: the Sierpinski arrowhead generated for multiple iterations _i_.

![Sierpinski triangles](/assets/posts/2020-8-23-Generating-L-systems/Sierpinksi.png "It's like a triforce."){: .figure .centre .huge}

## The code
Now that we know what an L-system is and how it should be generated in _theory_, we can start creating an simple l-system generator in code. Our approach will be simple and sequential, which is more than adequate for most implementations of L-system generators. There are more advanced parallel solutions, which we will discuss in the next post. First though, like many algorithms, it is important to learn how to solve the problem sequentially. 

Let's translate our L-system's tuple to a simple set of structures:

```C
typedef struct {
    const char antecedent;
    const char * consequent;
    size_t rewrite_length;
} Rule;

typedef struct {
    char * symbols;
    size_t length;
    size_t space;
} SymbolList;

typedef struct {
    Rule * rules;
    size_t length;
    size_t space;
} RuleList;

typedef struct {
    const SymbolList axiom;
    const RuleList rules;
} LSystem
```

I'm sorry for those who don't like C very much (I understand why, I just tend to enjoy the clear view of memory it provides, please bear with me). You should look primarily at lines 19 to 22 in any case. We have our `axiom` representing $$\omega$$ and our `rules` representing $$P$$. Once we have loaded any given L-system into our structure above (using, for example `bool try_load_system(LSystem * system, const char * file_path)`), we can start applying the rules for $$N$$ interactions.

```C
const size_t MAX_SYMBOLS 1e15;

void generate_system(LSystem * system, unsigned int num_iterations) {
    for (unsigned int iteration = 0; iteration < num_iterations; iteration++) {
        apply_rules_to_symbols(system.rules, &system.axiom);
        if (system.axiom.length > MAX_SYMBOLS) {
            printf("The axiom is too large, try decreasing the iterations.");
            return;
        }
    }
}
```

You will notice a two things.

- `MAX_SYMBOLS` is there to prevent a memory overflow. The same holds for lines 6-9, we check the size of the current iterations's axiom and exit the current iteration if it is too large. Decrease or increase the maximum depending on the amount of CPU memory available on your machine. One symbol requires 1 byte of memory, so if you have 6 GB of free memory you will have space for about $$6*10^9$$ symbols.
- `apply_rules_to_symbols` is called for `num_iterations` times ($$N$$). This is the crux of our implementation, simple repeated rewriting.

Let's look at the implementation of this repeated rewrite method.

```C
void apply_rules_to_symbols(RuleList rule_list, SymbolList * symbol_list) {
    SymbolList next_symbol_list = copy_symbol_list(symbol_list);
    for (unsigned int symbol_index = 0; symbol_index < symbol_list->length; symbol_index++) {
        const char symbol = symbol_list->symbols[symbol_index];
        
        unsigned int rule_index = 0;
        for (; rule_index < rule_list.length; rule_index++) {
            Rule rule = rule_list.rules[rule_index];
            if (rule.antecedent == symbol) {
                add_symbols_to_list(rule.consequent, &next_symbol_list);
                break;
            }
        }

        if (rule_index == rule_list.length)
            add_symbol_to_list(symbol, &next_symbol_list);
    }
    swap_symbol_list(symbol_list, &next_symbol_list);
    free_symbol_list(&next_symbol_list);
}
```

## References

Some references.
