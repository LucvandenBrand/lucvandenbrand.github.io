{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/metaGrid.js","webpack:///./src/app/main.js","webpack:///./src/app/control.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","MetaGrid","[object Object]","size","depth","parent","_cells","_element","document","createElement","_mark","_enabled","updateElement","this","isMarked","setAttribute","isEnabled","classList","add","remove","getMetaIndex","childGrid","isLeaf","childIndex","childRow","childCol","row","indexOf","col","getChildIndex","isRoot","concat","getChild","getElement","getSize","getParent","setMark","mark","getMark","enable","enabled","length","innerHTML","cell","push","appendChild","makeChildren","metaSlider","getElementById","metaDisplay","setMetaDisplay","innerText","String","oninput","onclick","gridContainer","metaGrid","rootGrid","_previousPlayer","applyToLeafs","grid","method","checkWin","checkMark","firstCell","checkRows","checkColumns","firstLeftCell","firstRightCell","leftDiagonal","rightDiagonal","index","mirrorIndex","checkDiagonals","isFilled","numChildren","numMarked","countMarked","enableReverse","metaIndex","child","findEmpty","leaf","pop","handleClick","gridLeaf","player","currentPlayer"],"mappings":"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","file":"metaTTT.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import '../styles/grid.css';\n\n/**\n * Defines a grid that can contain other grids.\n */\nexport class MetaGrid {\n    /**\n     * Construct a meta grid.\n     * @param {Number} size The size of the square grid.\n     * @param {Number} depth The number of nested grids inside this grid.\n     * @param {MetaGrid | undefined} parent The parent of this grid, undefined means this is the root.\n     */\n    constructor(size, depth, parent) {\n        const ATTR_MARK = 'mark',\n              ELEM_GRID = 'div',\n              CLASS_ENABLED = 'enabled';\n\n        const _cells = [];\n        const _element = document.createElement(ELEM_GRID);\n        let _mark;\n        let _enabled = false;\n\n        const updateElement = () => {\n            if (this.isMarked())\n                _element.setAttribute(ATTR_MARK, _mark);\n            if (this.isEnabled())\n                _element.classList.add(CLASS_ENABLED);\n            else\n                _element.classList.remove(CLASS_ENABLED);\n        };\n\n        const makeChildren = () => {\n            _cells.length = 0;\n            _element.innerHTML = '';\n            for (let row = 0; row < size; row++) {\n                _cells[row] = [];\n                for (let col = 0; col < size; col++) {\n                    const cell = new MetaGrid(size, depth - 1, this);\n                    _cells[row].push(cell);\n                    _element.appendChild(cell.getElement());\n                }\n            }\n        };\n\n        const getChildIndex = childGrid => {\n            let childRow = -1;\n            let childCol = -1;\n            for (let row = 0; row < size; row++) {\n                childCol = _cells[row].indexOf(childGrid);\n                if (childCol >= 0) {\n                    childRow = row;\n                    break;\n                }\n            }\n\n            return {row: childRow, col: childCol};\n        };\n\n        /**\n         * Return the index of the grid in its nested state.\n         * @param {MetaGrid} childGrid\n         * @return {Object[]} List of objects containing (row, col) indices.\n         */\n        this.getMetaIndex = childGrid => {\n            if (this.isLeaf())\n                return parent.getMetaIndex(this);\n\n            const childIndex = getChildIndex(childGrid);\n\n            if (this.isRoot())\n                return [childIndex];\n\n            return parent.getMetaIndex(this).concat(childIndex);\n        };\n\n        /**\n         * Return the nested child at (row, col).\n         * @param {Number} row The row that contains the child.\n         * @param {Number} col The column that contains the child.\n         * @return {MetaGrid | undefined} Meta grid if it exists, otherwise undefined.\n         */\n        this.getChild = (row, col) => {\n            if (!this.isLeaf())\n                return _cells[row][col];\n        };\n\n        /**\n         * Return the HTMLElement visualizing the meta grid.\n         * @return {HTMLDivElement}\n         */\n        this.getElement = () => _element;\n\n        /**\n         * Return the size of this meta grid.\n         * @return {Number}\n         */\n        this.getSize = () => size;\n\n        /**\n         * Return the parent of this meta grid.\n         * @return {MetaGrid}\n         */\n        this.getParent = () => parent;\n\n        /**\n         * Return true if this meta grid contains no children.\n         * @return {boolean}\n         */\n        this.isLeaf = () => {\n            return depth === 0;\n        };\n\n        /**\n         * Return true if this meta grid contains no parent.\n         * @return {boolean}\n         */\n        this.isRoot = () => {\n            return parent == null;\n        };\n\n        /**\n         * Assign a mark to this meta grid.\n         * @param {Number} mark Mark to assign.\n         */\n        this.setMark = mark => {\n            _mark = mark;\n            updateElement();\n        };\n\n        /**\n         * Return the mark assigned to this meta grid.\n         * @return {Number} The mark of this grid.\n         */\n        this.getMark = () => {\n            return _mark;\n        };\n\n        /**\n         * Return true if this meta grid contains a mark.\n         * @return {boolean} True if this meta grid is marked.\n         */\n        this.isMarked = () => {\n            return _mark != null;\n        };\n\n        /**\n         * Enable or disable this meta grid for interaction.\n         * @param {boolean} enabled True if this meta grid can be interacted with.\n         */\n        this.enable = enabled => {\n            _enabled = enabled;\n            updateElement();\n        };\n\n        /**\n         * Return true if this meta grid can be interacted with.\n         * @return {boolean} True if this meta grid can be interacted with.\n         */\n        this.isEnabled = () => _enabled;\n\n        if (!this.isLeaf())\n            makeChildren();\n\n        updateElement();\n    }\n}\n","import { MetaGrid } from './metaGrid';\nimport { Control } from './control';\n\nimport '../styles/main.css';\n\nconst ID_CONTAINER = 'grid-container',\n      ID_META_SLIDER = 'meta-level',\n      ID_META_DISPLAY = 'level-value',\n      ID_NEW_GAME_BUTTON = 'new-game',\n      GRID_SIZE = 3;\n\nconst metaSlider = document.getElementById(ID_META_SLIDER);\nconst metaDisplay = document.getElementById(ID_META_DISPLAY);\n\nconst setMetaDisplay = () => {\n    metaDisplay.innerText = String(metaSlider.value - 1)\n};\n\nsetMetaDisplay();\nmetaSlider.oninput = setMetaDisplay;\n\ndocument.getElementById(ID_NEW_GAME_BUTTON).onclick = () => {\n    const gridContainer = document.getElementById(ID_CONTAINER);\n    gridContainer.innerHTML = '';\n    const metaGrid = new MetaGrid(GRID_SIZE, metaSlider.value);\n    gridContainer.appendChild(metaGrid.getElement());\n    new Control(metaGrid);\n};","/**\n * Handles game-play logic and player control.\n */\nexport class Control {\n    /**\n     * Construct a control object and attach it to the root grid.\n     * @param {MetaGrid} rootGrid The root of a MetaGrid.\n     */\n    constructor(rootGrid) {\n        let _previousPlayer = 0;\n\n        const currentPlayer = () => {\n            return _previousPlayer ^= 1;\n        };\n\n        const applyToLeafs = (grid, method) => {\n            if (grid.isLeaf()) {\n                method(grid);\n                return;\n            }\n\n            for (let row = 0; row < grid.getSize(); row++) {\n                for (let col = 0; col < grid.getSize(); col++) {\n                    applyToLeafs(grid.getChild(row, col), method);\n                }\n            }\n        };\n\n        const checkRows = grid => {\n            for (let row = 0; row < grid.getSize(); row++) {\n                const firstCell = grid.getChild(row, 0).getMark();\n                if (firstCell == null)\n                    continue;\n\n                let col;\n                for (col = 0; col < grid.getSize(); col++) {\n                    if (grid.getChild(row, col).getMark() !== firstCell)\n                        break;\n                }\n\n                if (col === grid.getSize())\n                    return true;\n            }\n\n            return false;\n        };\n\n        const checkColumns = grid => {\n            for (let col = 0; col < grid.getSize(); col++) {\n                const firstCell = grid.getChild(0, col).getMark();\n                if (firstCell == null)\n                    continue;\n\n                let row;\n                for (row = 0; row < grid.getSize(); row++) {\n                    if (grid.getChild(row, col).getMark() !== firstCell)\n                        break;\n                }\n\n                if (row === grid.getSize())\n                    return true;\n            }\n\n            return false;\n        };\n\n        const checkDiagonals = grid => {\n            const firstLeftCell = grid.getChild(0, 0).getMark();\n            const firstRightCell = grid.getChild(0, grid.getSize()-1).getMark();\n\n            let leftDiagonal = true, rightDiagonal = true;\n            for (let index = 0; index < grid.getSize(); index++) {\n                if (grid.getChild(index, index).getMark() !== firstLeftCell) {\n                    leftDiagonal = false;\n                }\n\n                let mirrorIndex = grid.getSize() - index - 1;\n                if (grid.getChild(index, mirrorIndex).getMark() !== firstRightCell) {\n                    rightDiagonal = false;\n                }\n            }\n            return firstLeftCell  != null && leftDiagonal ||\n                firstRightCell != null && rightDiagonal;\n        };\n\n        const checkWin = (grid, checkMark) => {\n            if (grid.isMarked())\n                return;\n\n            if (checkRows(grid) || checkColumns(grid) || checkDiagonals(grid)) {\n                grid.setMark(checkMark);\n\n                if (!grid.isRoot())\n                    checkWin(grid.getParent(), checkMark);\n            }\n        };\n\n        const countMarked = grid => {\n            let numMarked = 0;\n            for (let row = 0; row < grid.getSize(); row++)\n                for (let col = 0; col < grid.getSize(); col++)\n                    if (grid.getChild(row, col).isMarked())\n                        numMarked++;\n            return numMarked;\n        };\n\n        const isFilled = grid => {\n            const numChildren = grid.getSize() * grid.getSize();\n            return countMarked(grid) === numChildren;\n        };\n\n        const findEmpty = grid => {\n            for (let row = 0; row < grid.getSize(); row++) {\n                for (let col = 0; col < grid.getSize(); col++) {\n                    const child = grid.getChild(row, col);\n                    if (!isFilled(child)) {\n                        return child;\n                    }\n                }\n            }\n        };\n\n        const enableReverse = (grid, metaIndex) => {\n            if (metaIndex.length === 1) {\n                if (isFilled(grid) && !grid.isRoot())\n                    grid = findEmpty(grid.getParent());\n\n                if (grid == null)\n                    return;\n\n                applyToLeafs(grid, (leaf) => {\n                    leaf.enable(true);\n                });\n\n                return;\n            }\n\n            const childIndex = metaIndex.pop();\n            let child = grid.getChild(childIndex.row, childIndex.col);\n            enableReverse(child, metaIndex);\n        };\n\n        const handleClick = gridLeaf => {\n            const player = currentPlayer();\n            if (gridLeaf.isEnabled() && !gridLeaf.isMarked()) {\n                gridLeaf.setMark(player);\n                checkWin(gridLeaf.getParent(), player);\n\n                applyToLeafs(rootGrid, (leaf) => {\n                    leaf.enable(false);\n                });\n\n                enableReverse(rootGrid, gridLeaf.getMetaIndex());\n            }\n        };\n\n        applyToLeafs(rootGrid, (leaf) => {\n            leaf.getElement().onclick = () => {handleClick(leaf)};\n            leaf.enable(true);\n        });\n    }\n}"],"sourceRoot":""}